import React, { useState, useEffect, useRef, useCallback } from 'react';
import './EnhancedInsightDisplay.css';

const BOOKMARKS_KEY = 'bazi-bookmarks';

const getBookmarks = () => {
  try {
    const raw = localStorage.getItem(BOOKMARKS_KEY);
    const arr = raw ? JSON.parse(raw) : [];
    return Array.isArray(arr) ? arr : [];
  } catch {
    return [];
  }
};

const saveBookmarks = (ids) => {
  try {
    localStorage.setItem(BOOKMARKS_KEY, JSON.stringify(ids));
  } catch (e) {
    console.error('Failed to save bookmarks', e);
  }
};

const LABELS = {
  header: { en: 'BAZI Destiny Analysis', 'zh-TW': 'å…«å­—å‘½é‹åˆ†æž', 'zh-CN': 'å…«å­—å‘½è¿åˆ†æž', ko: 'ì‚¬ì£¼ ìš´ëª… ë¶„ì„' },
  subtitle: { en: 'Structured interpretation of your life chart', 'zh-TW': 'æ‚¨çš„äººç”Ÿå‘½ç›¤çµæ§‹åŒ–è§£è®€', 'zh-CN': 'æ‚¨çš„äººç”Ÿå‘½ç›˜ç»“æž„åŒ–è§£è¯»', ko: 'ì¸ìƒ ì°¨íŠ¸ì˜ êµ¬ì¡°í™”ëœ í•´ì„' },
  empty: { en: 'Insights will appear here...', 'zh-TW': 'åˆ†æžçµæžœå°‡åœ¨æ­¤é¡¯ç¤º...', 'zh-CN': 'åˆ†æžç»“æžœå°†åœ¨æ­¤æ˜¾ç¤º...', ko: 'ë¶„ì„ ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤...' },
  overview: { en: 'Overview', 'zh-TW': 'ç¸½è¦½', 'zh-CN': 'æ€»è§ˆ', ko: 'ê°œìš”' },
  analysis: { en: 'Analysis', 'zh-TW': 'åˆ†æž', 'zh-CN': 'åˆ†æž', ko: 'ë¶„ì„' },
  copied: { en: 'Copied!', 'zh-TW': 'å·²è¤‡è£½ï¼', 'zh-CN': 'å·²å¤åˆ¶ï¼', ko: 'ë³µì‚¬ë¨!' },
};

export const EnhancedInsightDisplay = ({ insights, language = 'en' }) => {
  const [sections, setSections] = useState([]);
  const [activeSection, setActiveSection] = useState(0);
  const [copiedIndex, setCopiedIndex] = useState(null);
  const [bookmarks, setBookmarksState] = useState(getBookmarks);
  const [showBookmarksOnly, setShowBookmarksOnly] = useState(false);
  const containerRef = useRef(null);
  const sectionRefs = useRef([]);

  useEffect(() => {
    let text = typeof insights === 'string' ? insights : '';
    if (!text || typeof text !== 'string') {
      setSections([]);
      return;
    }

    // Strip common AI disclaimer phrases (anywhere in text, not just at end)
    const disclaimerPatterns = [
      /ä»¥ä¸Šå†…å®¹ç”±DeepSeekç”Ÿæˆï¼Œä»…ä¾›å‚è€ƒ[ã€‚\s]*/g,
      /ä»¥ä¸Šå…§å®¹ç”±DeepSeekç”Ÿæˆï¼Œåƒ…ä¾›åƒè€ƒ[ã€‚\s]*/g,
      /The above content was generated by DeepSeek, for reference only\.?[\s]*/gi,
      /ì´ìƒ ë‚´ìš©ì€ DeepSeekì´ ìƒì„±í–ˆìŠµë‹ˆë‹¤[.ã€‚\s]*/g,
    ];
    for (const pattern of disclaimerPatterns) {
      text = text.replace(pattern, '')
    }
    text = text.trimEnd()

    try {
      const parsedSections = [];
      
      // First, extract the intro (everything before first ###)
      const introMatch = text.match(/^([\s\S]*?)(###\s+\d+\.)/);
      const intro = introMatch ? introMatch[1] : '';
      
      if (intro && intro.trim().length > 0) {
        parsedSections.push({
          type: 'intro',
          content: intro.trim(),
          title: 'Overview'
        });
      }

      // Now split by ### markers
      const parts = text.split(/###\s+/);
      
      // Skip first part (it's the intro we already processed)
      for (let i = 1; i < parts.length; i++) {
        const section = parts[i];
        if (!section || !section.trim || section.trim().length === 0) continue;
        const lines = section.split('\n');
        if (!lines || lines.length === 0) continue;  // â† Safe checks

        // First line should have number and title like "1. Chart Structure & Strength Analysis"
        const firstLine = lines[0] ? lines[0].trim() : '';
        
        // Extract just the title part (remove the number)
        const titleMatch = firstLine.match(/^\d+\.\s+(.+)$/);
        const title = titleMatch ? titleMatch[1] : firstLine;
        
        // Rest is content
        const content = lines.slice(1).join('\n').trim();

        if (title && content) {
          parsedSections.push({
            type: 'section',
            title: title,
            content: content
          });
        }
      }

      setSections(parsedSections);
    } catch (error) {
      console.error('Error parsing insights:', error);
      setSections([
        {
          type: 'raw',
          content: text,
          title: 'Analysis'
        }
      ]);
    }
  }, [insights]);

  // IntersectionObserver for scroll highlighting
  useEffect(() => {
    if (sections.length === 0) return;
    const observers = [];
    sectionRefs.current = sectionRefs.current.slice(0, sections.length);
    sections.forEach((_, index) => {
      const el = document.getElementById(`section-${index}`);
      if (!el) return;
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              setActiveSection(index);
            }
          });
        },
        { rootMargin: '-20% 0px -60% 0px', threshold: 0 }
      );
      observer.observe(el);
      observers.push(observer);
    });
    return () => observers.forEach((o) => o.disconnect());
  }, [sections]);

  const handleCopy = useCallback(async (index) => {
    const section = sections[index];
    if (!section?.content) return;
    try {
      await navigator.clipboard.writeText(`${section.title}\n\n${section.content}`);
      setCopiedIndex(index);
      setTimeout(() => setCopiedIndex(null), 2000);
    } catch (e) {
      console.error('Copy failed', e);
    }
  }, [sections]);

  const toggleBookmark = useCallback((index) => {
    const id = `section-${index}`;
    const next = bookmarks.includes(id) ? bookmarks.filter((b) => b !== id) : [...bookmarks, id];
    setBookmarksState(next);
    saveBookmarks(next);
  }, [bookmarks]);

  const getSectionIcon = (title) => {
    const iconMap = {
      'Chart Structure': 'ðŸ“Š',
      'Career & Finance': 'ðŸ’¼',
      'Relationships': 'ðŸ’‘',
      'Health': 'ðŸ¥',
      'Personality': 'âœ¨',
      'Luck Cycles': 'ðŸ”„',
      'Life Guidance': 'ðŸŽ¯',
      'Yearly Forecast': 'ðŸ“…',
      'æµå¹´å±•æœ›': 'ðŸ“…',
      'å‘½ç›˜ç»“æž„ä¸Žå¼ºå¼±åˆ†æž': 'ðŸ“Š',
      'å‘½ç›¤çµæ§‹èˆ‡å¼·å¼±åˆ†æž': 'ðŸ“Š',
      'èŒä¸šä¸Žè´¢å¯Œ': 'ðŸ’¼',
      'è·æ¥­èˆ‡è²¡å¯Œ': 'ðŸ’¼',
      'å…³ç³»ä¸Žå©šå§»': 'ðŸ’‘',
      'é—œä¿‚èˆ‡å©šå§»': 'ðŸ’‘',
      'å¥åº·ä¸Žå…»ç”Ÿ': 'ðŸ¥',
      'å¥åº·èˆ‡é¤Šç”Ÿ': 'ðŸ¥',
      'æ€§æ ¼ä¸Žå“è´¨': 'âœ¨',
      'æ€§æ ¼èˆ‡å“è³ª': 'âœ¨',
      'å¹¸è¿å‘¨æœŸä¸Žæ—¶æœº': 'ðŸ”„',
      'å¹¸é‹å‘¨æœŸèˆ‡æ™‚æ©Ÿ': 'ðŸ”„',
      'äººç”ŸæŒ‡å¼•ä¸Žä¸ªäººå‘å±•': 'ðŸŽ¯',
      'äººç”ŸæŒ‡å¼•èˆ‡å€‹äººç™¼å±•': 'ðŸŽ¯',
      'ì‚¬ì£¼ êµ¬ì¡°ì™€ ê°•ì•½ ë¶„ì„': 'ðŸ“Š',
      'ì§ì—…ê³¼ ìž¬ë¬¼': 'ðŸ’¼',
      'ê´€ê³„ì™€ ê²°í˜¼': 'ðŸ’‘',
      'ê±´ê°•ê³¼ ì–‘ìƒ': 'ðŸ¥',
      'ì„±ê²©ê³¼ í’ˆì„±': 'âœ¨',
      'ëŒ€ìš´ ì£¼ê¸°ì™€ ì‹œê¸°': 'ðŸ”„',
      'ì¸ìƒ ê°€ì´ë“œì™€ ìžê¸°ê³„ë°œ': 'ðŸŽ¯',
      'ì—°ê°„ ì „ë§': 'ðŸ“…',
    };
    for (const [key, icon] of Object.entries(iconMap)) {
      if (title.includes(key)) return icon;
    }
    return 'ðŸ“Œ';
  };

  const getSectionColor = (index) => {
    const colors = [
      'section-blue',
      'section-green',
      'section-purple',
      'section-orange',
      'section-pink',
      'section-teal',
      'section-amber'
    ];
    return colors[index % colors.length];
  };

  const getLabel = (key) => LABELS[key]?.[language] || LABELS[key]?.en || key;

  if (sections.length === 0) {
    const isStreaming = insights && typeof insights === 'string' && insights.length > 0;
    return (
      <div className="enhanced-insights-container">
        {isStreaming ? (
          <div className="sections-wrapper space-y-4">
            {[1, 2, 3, 4].map((i) => (
              <div key={i} className="insight-section animate-pulse bg-neutral-800/50 rounded-xl h-24 border border-white/5" />
            ))}
          </div>
        ) : (
          <div className="insights-empty">
            <p>{getLabel('empty')}</p>
          </div>
        )}
      </div>
    );
  }

  const scrollToSection = (index) => {
    const el = document.getElementById(`section-${index}`);
    el?.scrollIntoView({ behavior: 'smooth', block: 'start' });
  };

  return (
    <div className="enhanced-insights-container" ref={containerRef}>
      <div className="insights-header">
        <h2>{getLabel('header')}</h2>
        <p className="insights-subtitle">{getLabel('subtitle')}</p>
      </div>

      {/* Section navigation */}
      {sections.length > 1 && (
        <nav className="insights-nav mb-4 overflow-x-auto pb-2" aria-label="Section navigation">
          <div className="flex flex-wrap gap-2 items-center">
            {bookmarks.length > 0 && (
              <button
                type="button"
                onClick={() => setShowBookmarksOnly((v) => !v)}
                className={`px-2 py-1 rounded text-xs font-medium ${showBookmarksOnly ? 'bg-bazi-gold/30 text-amber-200' : 'bg-white/5 text-neutral-400 hover:text-amber-200'}`}
              >
                â˜… {bookmarks.length}
              </button>
            )}
            <div className="flex gap-2 min-w-max overflow-x-auto">
              {sections
                .map((section, index) => ({ section, index }))
                .filter(({ index }) => !showBookmarksOnly || bookmarks.includes(`section-${index}`))
                .map(({ section, index }) => (
                  <button
                    key={index}
                    type="button"
                    onClick={() => scrollToSection(index)}
                    className={`px-3 py-1.5 rounded-lg text-xs font-medium border transition-colors whitespace-nowrap ${
                      activeSection === index
                        ? 'bg-bazi-gold/30 text-amber-200 border-bazi-gold/50'
                        : 'bg-bazi-surface/80 border-white/5 text-amber-100 hover:border-amber-500/30 hover:bg-bazi-surface'
                    }`}
                  >
                    {getSectionIcon(section.title)} {section.type === 'intro' ? getLabel('overview') : section.type === 'raw' ? getLabel('analysis') : section.title}
                  </button>
                ))}
            </div>
          </div>
        </nav>
      )}

      <div className="sections-wrapper">
        {sections
          .map((section, index) => ({ section, index }))
          .filter(({ index }) => !showBookmarksOnly || bookmarks.includes(`section-${index}`))
          .map(({ section, index }) => (
          <div
            key={index}
            id={`section-${index}`}
            ref={(el) => { sectionRefs.current[index] = el }}
            className={`insight-section ${getSectionColor(index)} ${
              section.type === 'intro' ? 'intro-section' : ''
            } ${section.type === 'raw' ? 'raw-section' : ''}`}
          >
            <div className="section-header flex items-center justify-between gap-2">
              <div className="flex items-center gap-2 min-w-0">
                <span className="section-icon">{getSectionIcon(section.title)}</span>
                <h3 className="truncate">
                  {section.type === 'intro' ? getLabel('overview') : section.type === 'raw' ? getLabel('analysis') : section.title}
                </h3>
                {bookmarks.includes(`section-${index}`) && (
                  <span className="text-amber-400 text-xs shrink-0" title="Bookmarked">â˜…</span>
                )}
              </div>
              <div className="flex gap-1 shrink-0">
                <button
                  type="button"
                  onClick={() => toggleBookmark(index)}
                  className={`p-1.5 rounded text-xs transition-colors ${bookmarks.includes(`section-${index}`) ? 'text-amber-400' : 'text-neutral-500 hover:text-amber-300'}`}
                  aria-label={bookmarks.includes(`section-${index}`) ? 'Remove bookmark' : 'Bookmark'}
                >
                  â˜…
                </button>
                <button
                  type="button"
                  onClick={() => handleCopy(index)}
                  className="p-1.5 rounded text-xs text-neutral-500 hover:text-amber-300 transition-colors"
                  aria-label="Copy section"
                >
                  {copiedIndex === index ? 'âœ“' : 'âŽ˜'}
                </button>
              </div>
            </div>

            <div className="section-content">
              {section.type === 'raw' ? (
                <div className="raw-text">{section.content}</div>
              ) : (
                <FormattedContent content={section.content} />
              )}
            </div>
          </div>
        ))}
      </div>
      {copiedIndex !== null && (
        <div className="fixed bottom-4 left-1/2 -translate-x-1/2 px-4 py-2 rounded-lg bg-bazi-gold/90 text-bazi-ink text-sm font-medium animate-fade-in">
          {getLabel('copied')}
        </div>
      )}
    </div>
  );
};

// Helper to format content
const FormattedContent = ({ content }) => {
  if (!content || typeof content !== 'string') {
    return <p>No content available</p>;
  }

  const lines = content.split('\n');

  return (
    <div className="formatted-content">
      {lines.map((line, i) => {
        const trimmed = line.trim();
        if (!trimmed) return null;

        // Bold text (between **)
        if (trimmed.includes('**')) {
          return (
            <p key={i} className="content-line">
              {trimmed.split(/\*\*([^*]+)\*\*/).map((part, idx) =>
                idx % 2 === 1 ? <strong key={idx}>{part}</strong> : part
              )}
            </p>
          );
        }

        // Bullet points starting with *
        if (trimmed.startsWith('* ')) {
          return (
            <div key={i} className="bullet-point">
              â€¢ {trimmed.replace(/^\*\s*/, '')}
            </div>
          );
        }

        // Bullet points starting with -
        if (trimmed.startsWith('- ')) {
          return (
            <div key={i} className="bullet-point">
              â€¢ {trimmed.replace(/^-\s*/, '')}
            </div>
          );
        }

        // Section separator lines (---)
        if (trimmed === '---' || trimmed === '***') {
          return <div key={i} className="section-divider" />;
        }

        // Regular paragraph
        return (
          <p key={i} className="content-line">
            {trimmed}
          </p>
        );
      })}
    </div>
  );
};

export default EnhancedInsightDisplay;
